#line 1 "C:\\MINDCODETECH\\GAMEENGINE\\amdcodes\\TressFX11_v1.0\\TressFX11\\shaders\\Source\\kbuffer.hlsl"


#line 9


#line 1 "hairbasic.hlsl"


#line 9


#line 1 "common.hlsl"


#line 9









#line 19


#line 24
uint PackFloat4IntoUint ( float4 vValue ) 
{ 
    return ( ( uint ( vValue . x * 255 ) & 0xFFUL ) << 24 ) | ( ( uint ( vValue . y * 255 ) & 0xFFUL ) << 16 ) | ( ( uint ( vValue . z * 255 ) & 0xFFUL ) << 8 ) | ( uint ( vValue . w * 255 ) & 0xFFUL ) ; 
} 

float4 UnpackUintIntoFloat4 ( uint uValue ) 
{ 
    return float4 ( ( ( uValue & 0xFF000000 ) >> 24 ) / 255.0 , ( ( uValue & 0x00FF0000 ) >> 16 ) / 255.0 , ( ( uValue & 0x0000FF00 ) >> 8 ) / 255.0 , ( ( uValue & 0x000000FF ) ) / 255.0 ) ; 
} 

#line 35
uint PackDepthIntoUint ( float fDepth ) 
{ 
    return ( ( uint ) ( fDepth * ( ( 1 << 24 ) - 1 ) ) ) << 8 ; 
} 

#line 44
cbuffer cbPerFrame : register ( b0 ) 
{ 
    matrix g_mWorld : packoffset ( c0 ) ; 
    matrix g_mViewProj : packoffset ( c4 ) ; 
    matrix g_mInvViewProj : packoffset ( c8 ) ; 
    matrix g_mViewProjLight : packoffset ( c12 ) ; 
    
    float3 g_vEye : packoffset ( c16 ) ; 
    float g_fvFov : packoffset ( c16 . w ) ; 
    
    float4 g_AmbientLightColor : packoffset ( c17 ) ; 
    float4 g_PointLightColor : packoffset ( c18 ) ; 
    float4 g_PointLightPos : packoffset ( c19 ) ; 
    float4 g_MatBaseColor : packoffset ( c20 ) ; 
    float4 g_MatKValue : packoffset ( c21 ) ; 
    
    float g_FiberAlpha : packoffset ( c22 . x ) ; 
    float g_HairShadowAlpha : packoffset ( c22 . y ) ; 
    float g_bExpandPixels : packoffset ( c22 . z ) ; 
    float g_FiberRadius : packoffset ( c22 . w ) ; 
    
    float g_fHairKs2 : packoffset ( c23 . x ) ; 
    float g_fHairEx2 : packoffset ( c23 . y ) ; 
    float2 g_WinSize : packoffset ( c23 . z ) ; 
    
    float g_FiberSpacing : packoffset ( c24 . x ) ; 
    float g_bThinTip : packoffset ( c24 . y ) ; 
    float g_fNearLight : packoffset ( c24 . z ) ; 
    float g_fFarLight : packoffset ( c24 . w ) ; 
    
    int g_iTechSM : packoffset ( c25 . x ) ; 
    int g_bUseCoverage : packoffset ( c25 . y ) ; 
    int g_bUseAltCoverage : packoffset ( c25 . z ) ; 
    int g_iStrandCopies : packoffset ( c25 . w ) ; 
} ; 

cbuffer cbPerMaterial : register ( b1 ) 
{ 
    float4 g_MatAmbient : packoffset ( c0 ) ; 
    float4 g_MatDiffuse : packoffset ( c1 ) ; 
    float4 g_MatSpecular : packoffset ( c2 ) ; 
    float4 g_ScalpColor : packoffset ( c3 ) ; 
} ; 

struct Eye_Fragment_STRUCT 
{ 
    uint uPixelColor ; 
    uint uDepthAndCoverage ; 
    uint uNext ; 
} ; 

struct Eye_Node_STRUCT 
{ 
    uint next ; 
    uint uColor ; 
    uint uDepth ; 
} ; 

struct HAIR_VERTEX 
{ 
    float3 pos ; 
    float3 tangent ; 
    float4 texcoord ; 
} ; 

#line 113
Buffer < uint > EyeRefSRV : register ( t0 ) ; 
StructuredBuffer < Eye_Fragment_STRUCT > EyeFragmentSRV : register ( t1 ) ; 

Texture2D g_txSMScene : register ( t2 ) ; 
Texture2D g_txSMHair : register ( t3 ) ; 
Texture2D g_txObj : register ( t4 ) ; 
Texture2D g_txNoise : register ( t5 ) ; 

Buffer < uint > g_HairIndices : register ( t6 ) ; 
Buffer < float > g_HairThicknessCoeffs : register ( t7 ) ; 

StructuredBuffer < float4 > g_GuideHairVertexPositions : register ( t8 ) ; 
StructuredBuffer < float4 > g_GuideHairVertexTangents : register ( t9 ) ; 

#line 130
SamplerState g_samLinearWrap : register ( s0 ) ; 
SamplerState g_samPointClamp : register ( s1 ) ; 
SamplerComparisonState g_samShadow : register ( s2 ) ; 

#line 137
RWByteAddressBuffer EyeRefUAV : register ( u1 ) ; 
RWStructuredBuffer < Eye_Fragment_STRUCT > EyeFragmentUAV : register ( u2 ) ; 

#line 143
struct VS_INPUT_SCENE 
{ 
    float3 Position : POSITION ; 
    float3 Normal : NORMAL ; 
    float2 Texcoord : TEXCOORD0 ; 
} ; 

struct VS_INPUT_Hair 
{ 
    float3 Position : POSITION ; 
    float3 Tangent : TANGENT ; 
    float4 Texcoord : TEXCOORD0 ; 
    uint id : SV_VERTEXID ; 
} ; 

struct PS_INPUT_HAIR_AA 
{ 
    float4 Position : SV_POSITION ; 
    float3 Tangent : Tangent ; 
    float4 Texcoord : TEXCOORD0 ; 
    float3 WorldPos : TEXCOORD1 ; 
    float3 p0 : TEXCOORD2 ; 
    float3 p1 : TEXCOORD3 ; 
} ; 

struct VS_OUTPUT_SM 
{ 
    float4 Position : SV_POSITION ; 
    float3 WorldPos : TEXCOORD0 ; 
} ; 

#line 178
struct VS_OUTPUT_SCREENQUAD 
{ 
    float4 vPosition : SV_POSITION ; 
    float2 vTex : TEXCOORD ; 
} ; 

#line 186
VS_OUTPUT_SCREENQUAD VS_ScreenQuad ( VS_INPUT_SCENE input ) 
{ 
    VS_OUTPUT_SCREENQUAD output ; 
    
    output . vPosition = float4 ( input . Position . xyz , 1.0 ) ; 
    output . vTex = input . Texcoord . xy ; 
    
    return output ; 
} 

#line 197
struct VS_OUTPUT_SCENE 
{ 
    float4 Position : SV_POSITION ; 
    float3 Normal : TEXCOORD0 ; 
    float2 Texcoord : TEXCOORD1 ; 
    float3 WorldPos : TEXCOORD2 ; 
} ; 



#line 1 "shadow.hlsl"


#line 9



struct INPUT_SHADOW 
{ 
    float3 pos ; 
} ; 

struct AmountLight 
{ 
    float amountLight_scene ; 
    float amountLight_hair ; 
} ; 

#line 28
AmountLight ComputeShadow_SDSM ( INPUT_SHADOW input , float alpha ) 
{ 
    float4 projPosLight = mul ( float4 ( input . pos , 1 ) , g_mViewProjLight ) ; 
    float2 texSM = float2 ( projPosLight . x / projPosLight . w + 1 , - projPosLight . y / projPosLight . w + 1 ) * 0.5 ; 
    float depth = projPosLight . z / projPosLight . w ; 
    float epslon = depth * 0.01 ; 
    float depth_fragment = projPosLight . w ; 
    
#line 37
    float total_weight = 0 ; 
    AmountLight amountLight ; 
    amountLight . amountLight_hair = 0 ; 
    amountLight . amountLight_scene = 0 ; 
    
    [ unroll ] for ( int dx = ( 1 - 3 ) / 2 ; dx <= 3 / 2 ; dx ++ ) 
    { 
        [ unroll ] for ( int dy = ( 1 - 3 ) / 2 ; dy <= 3 / 2 ; dy ++ ) 
        { 
            float size = 2.4 ; 
            float sigma = ( 3 / 2.0 ) / size ; 
            float exp = - 1 * ( dx * dx + dy * dy ) / ( 2 * sigma * sigma ) ; 
            float weight = 1 / ( 2 * 3.1415926 * sigma * sigma ) * pow ( 2.71828183 , exp ) ; 
            
#line 52
            amountLight . amountLight_scene += weight * g_txSMScene . SampleCmpLevelZero ( g_samShadow , texSM , depth - epslon , int2 ( dx , dy ) ) ; 
            
#line 55
            float depthSMHair = g_txSMHair . SampleLevel ( g_samPointClamp , texSM , 0 , int2 ( dx , dy ) ) . x ; 
            
            float depth_smPoint = g_fNearLight / ( 1 - depthSMHair * ( g_fFarLight - g_fNearLight ) / g_fFarLight ) ; 
            
            float depth_range = max ( 0 , depth_fragment - depth_smPoint ) ; 
            float numFibers = depth_range / ( g_FiberSpacing * g_FiberRadius ) ; 
            
#line 63
            if ( depth_range > 1e-5 ) 
            numFibers += 1 ; 
            amountLight . amountLight_hair += pow ( abs ( 1 - alpha ) , numFibers ) * weight ; 
            
            total_weight += weight ; 
        } 
    } 
    amountLight . amountLight_hair /= total_weight ; 
    amountLight . amountLight_scene /= total_weight ; 
    return amountLight ; 
} 

AmountLight ComputeShadow ( INPUT_SHADOW input , float alpha , int iTechSM ) 
{ 
    AmountLight amountLight ; 
    amountLight . amountLight_hair = 1 ; 
    amountLight . amountLight_scene = 1 ; 
    
    if ( iTechSM == 2 ) 
    amountLight = ComputeShadow_SDSM ( input , alpha ) ; 
    
    return amountLight ; 
} 


#line 205 "common.hlsl"


#line 11 "hairbasic.hlsl"
float ComputeCoverage ( float3 eye , float3 ray_dir , float3 p0 , float3 p1 , float2 winSizeEye , float fiber_radius ) 
{ 
    float pixel_coverage = 0 ; 
    
#line 16
    float3 nv0 = normalize ( ray_dir ) ; 
    float3 nv1 = normalize ( p1 - p0 ) ; 
    
#line 20
    float3 norm = cross ( nv0 , nv1 ) ; 
    float3 nnorm = normalize ( norm ) ; 
    
    float sin_v0_v1 = length ( norm ) ; 
    
#line 26
    float3 eye_p0 = p0 - eye ; 
    
#line 29
    float dis_lines = dot ( eye_p0 , nnorm ) ; 
    
#line 32
    float3 eye_p2 = eye_p0 - nnorm * dis_lines ; 
    float3 nv2 = normalize ( eye_p2 ) ; 
    
#line 36
    float dis_eye_p2 = length ( eye_p2 ) ; 
    
    float sin_v1_mv2 = length ( cross ( nv1 , - nv2 ) ) ; 
    
    float depth = sin_v1_mv2 * dis_eye_p2 / sin_v0_v1 ; 
    
#line 43
    if ( depth > 0 ) 
    { 
        
        float lengthPerPixel = 2 * depth * tan ( g_fvFov / 2 ) / winSizeEye . y ; 
        
        float coverage_right = min ( lengthPerPixel / 2 , dis_lines + fiber_radius ) ; 
        float coverage_left = max ( - lengthPerPixel / 2 , dis_lines - fiber_radius ) ; 
        
        pixel_coverage = max ( 0 , coverage_right - coverage_left ) / lengthPerPixel ; 
    } 
    
    return pixel_coverage ; 
} 

float FastComputeCoverage ( float2 p0 , float2 p1 , float2 pixelLoc ) 
{ 
    
#line 62
    p0 *= g_WinSize . xy ; 
    p1 *= g_WinSize . xy ; 
    pixelLoc *= g_WinSize . xy ; 
    
    float p0dist = length ( p0 - pixelLoc ) ; 
    float p1dist = length ( p1 - pixelLoc ) ; 
    float hairWidth = length ( p0 - p1 ) ; 
    
#line 71
    float outside = any ( float2 ( step ( hairWidth , p0dist ) , step ( hairWidth , p1dist ) ) ) ; 
    
#line 74
    float sign = outside > 0.f ? - 1.f : 1.f ; 
    
#line 77
    float relDist = sign * saturate ( min ( p0dist , p1dist ) ) ; 
    
#line 82
    return ( relDist + 1.f ) * 0.5f ; 
} 

VS_OUTPUT_SM VS_GenerateHairSM ( VS_INPUT_Hair input ) 
{ 
    VS_OUTPUT_SM Output ; 
    
    float4 pos = g_GuideHairVertexPositions [ input . id ] ; 
    
#line 92
    Output . Position = mul ( float4 ( pos . xyz , 1 ) , g_mViewProjLight ) ; 
    
    Output . WorldPos = pos . xyz ; 
    
    return Output ; 
} 

#line 101
static const uint HairVertexSelection [ ] = { 0 , 1 , 0 , 1 , 1 , 0 } ; 
static const float OffsetDirection [ ] = { - 1.f , - 1.f , 1.f , - 1.f , 1.f , 1.f } ; 
static const uint OffsetDirectionIndex [ ] = { 0 , 0 , 1 , 0 , 1 , 1 } ; 

PS_INPUT_HAIR_AA VS_RenderHairNoGS ( uint vertexId : SV_VertexID ) 
{ 
    
    uint offset = 2 * ( vertexId / ( 6 ) ) ; 
    
#line 111
    uint2 indices ; 
    indices . x = g_HairIndices . Load ( offset ) ; 
    indices . y = g_HairIndices . Load ( offset + 1 ) ; 
    
#line 116
    float ratio [ ] = { 1.f , 1.f } ; 
    
    if ( g_bThinTip > 0 ) 
    { 
        ratio [ 0 ] = g_HairThicknessCoeffs [ indices . x ] ; 
        ratio [ 1 ] = g_HairThicknessCoeffs [ indices . y ] ; 
    } 
    
#line 125
    float3 t [ ] = { normalize ( g_GuideHairVertexTangents [ indices . x ] . xyz ) , normalize ( g_GuideHairVertexTangents [ indices . y ] . xyz ) } ; 
    float3 v [ ] = { g_GuideHairVertexPositions [ indices . x ] . xyz , g_GuideHairVertexPositions [ indices . y ] . xyz } ; 
    float3 right [ ] = { normalize ( cross ( t [ 0 ] , normalize ( v [ 0 ] - g_vEye ) ) ) , normalize ( cross ( t [ 1 ] , normalize ( v [ 1 ] - g_vEye ) ) ) } ; 
    float2 proj_right [ ] = { normalize ( mul ( float4 ( right [ 0 ] , 0 ) , g_mViewProj ) . xy ) , normalize ( mul ( float4 ( right [ 1 ] , 0 ) , g_mViewProj ) . xy ) } ; 
    
    float expandPixels = .71f ; 
    if ( g_bExpandPixels < 0 ) 
    expandPixels = 0.f ; 
    
    PS_INPUT_HAIR_AA Output = ( PS_INPUT_HAIR_AA ) 0 ; 
    
#line 137
    uint localVertId = vertexId % ( 6 ) ; 
    uint idx = HairVertexSelection [ localVertId ] ; 
    float offDirCoef = OffsetDirection [ localVertId ] ; 
    
    float3 temp = v [ idx ] + offDirCoef * right [ idx ] * ratio [ idx ] * g_FiberRadius ; 
    Output . Position = mul ( float4 ( temp , 1.f ) , g_mViewProj ) ; 
    Output . Position = ( Output . Position / Output . Position . w ) + offDirCoef * float4 ( proj_right [ idx ] * expandPixels / g_WinSize . y , 0.f , 0.f ) ; 
    Output . Texcoord = float4 ( 0.f , 0.f , ratio [ idx ] , 0.f ) ; 
    Output . Tangent = t [ idx ] ; 
    Output . WorldPos = v [ idx ] ; 
    Output . p0 = v [ 0 ] ; 
    Output . p1 = v [ 1 ] ; 
    
    return Output ; 
} 

PS_INPUT_HAIR_AA VS_RenderHairNoGS_StrandCopies ( uint vertexId : SV_VertexID ) 
{ 
    uint RANDOMIZED_GENERATED_VERTEX_COUNT = ( 6 ) * g_iStrandCopies ; 
    
#line 158
    uint offset = 2 * ( vertexId / RANDOMIZED_GENERATED_VERTEX_COUNT ) ; 
    
#line 161
    uint randOffsetIndex = ( vertexId % RANDOMIZED_GENERATED_VERTEX_COUNT ) / ( 6 ) ; 
    
#line 164
    uint seedRand = ( ( offset / 64 + 1 ) * ( randOffsetIndex + 1 ) ) % 512 ; 
    float2 seedTexcorrd = float2 ( float ( seedRand % 512 ) , float ( seedRand / 512 ) ) * ( 1.f / 512.f ) ; 
    float3 randOffset = float3 ( 0 , 0 , 0 ) ; 
    randOffset = float ( randOffsetIndex ) * g_txNoise . SampleLevel ( g_samLinearWrap , seedTexcorrd , 0 ) . xyz ; 
    randOffset = 2.f * randOffset - 1.f ; 
    
#line 171
    uint2 indices ; 
    indices . x = g_HairIndices . Load ( offset ) ; 
    indices . y = g_HairIndices . Load ( offset + 1 ) ; 
    
#line 176
    float ratio [ ] = { 1.f , 1.f } ; 
    
    if ( g_bThinTip > 0 ) 
    { 
        ratio [ 0 ] = g_HairThicknessCoeffs [ indices . x ] ; 
        ratio [ 1 ] = g_HairThicknessCoeffs [ indices . y ] ; 
    } 
    
#line 185
    float3 t [ ] = { normalize ( g_GuideHairVertexTangents [ indices . x ] . xyz ) , normalize ( g_GuideHairVertexTangents [ indices . y ] . xyz ) } ; 
    float3 v [ ] = { randOffset + g_GuideHairVertexPositions [ indices . x ] . xyz , randOffset + g_GuideHairVertexPositions [ indices . y ] . xyz } ; 
    float3 right [ ] = { normalize ( cross ( t [ 0 ] , normalize ( v [ 0 ] - g_vEye ) ) ) , normalize ( cross ( t [ 1 ] , normalize ( v [ 1 ] - g_vEye ) ) ) } ; 
    float2 proj_right [ ] = { normalize ( mul ( float4 ( right [ 0 ] , 0 ) , g_mViewProj ) . xy ) , normalize ( mul ( float4 ( right [ 1 ] , 0 ) , g_mViewProj ) . xy ) } ; 
    
    float expandPixels = .71f ; 
    if ( g_bExpandPixels < 0 ) 
    expandPixels = 0.f ; 
    
    PS_INPUT_HAIR_AA Output = ( PS_INPUT_HAIR_AA ) 0 ; 
    
#line 197
    uint localVertId = vertexId % ( 6 ) ; 
    uint idx = HairVertexSelection [ localVertId ] ; 
    float offDirCoef = OffsetDirection [ localVertId ] ; 
    
    float3 temp = v [ idx ] + offDirCoef * right [ idx ] * ratio [ idx ] * g_FiberRadius ; 
    Output . Position = mul ( float4 ( temp , 1.f ) , g_mViewProj ) ; 
    Output . Position = ( Output . Position / Output . Position . w ) + offDirCoef * float4 ( proj_right [ idx ] * expandPixels / g_WinSize . y , 0.f , 0.f ) ; 
    Output . Texcoord = float4 ( 0.f , 0.f , ratio [ idx ] , 0.f ) ; 
    Output . Tangent = t [ idx ] ; 
    Output . WorldPos = v [ idx ] ; 
    Output . p0 = v [ 0 ] ; 
    Output . p1 = v [ 1 ] ; 
    
    return Output ; 
} 

PS_INPUT_HAIR_AA VS_RenderHairNoGS_AlternativeCoverage ( uint vertexId : SV_VertexID ) 
{ 
    
    uint offset = 2 * ( vertexId / ( 6 ) ) ; 
    
#line 219
    uint2 indices ; 
    indices . x = g_HairIndices . Load ( offset ) ; 
    indices . y = g_HairIndices . Load ( offset + 1 ) ; 
    
#line 224
    float ratio [ ] = { 1.f , 1.f } ; 
    
    if ( g_bThinTip > 0 ) 
    { 
        ratio [ 0 ] = g_HairThicknessCoeffs [ indices . x ] ; 
        ratio [ 1 ] = g_HairThicknessCoeffs [ indices . y ] ; 
    } 
    
#line 233
    float3 t [ ] = { normalize ( g_GuideHairVertexTangents [ indices . x ] . xyz ) , normalize ( g_GuideHairVertexTangents [ indices . y ] . xyz ) } ; 
    float3 v [ ] = { g_GuideHairVertexPositions [ indices . x ] . xyz , g_GuideHairVertexPositions [ indices . y ] . xyz } ; 
    float3 right [ ] = { normalize ( cross ( t [ 0 ] , normalize ( v [ 0 ] - g_vEye ) ) ) , normalize ( cross ( t [ 1 ] , normalize ( v [ 1 ] - g_vEye ) ) ) } ; 
    float2 proj_right [ ] = { normalize ( mul ( float4 ( right [ 0 ] , 0 ) , g_mViewProj ) . xy ) , normalize ( mul ( float4 ( right [ 1 ] , 0 ) , g_mViewProj ) . xy ) } ; 
    
    float expandPixels = .71f ; 
    if ( g_bExpandPixels < 0 ) 
    expandPixels = 0.f ; 
    
    PS_INPUT_HAIR_AA Output = ( PS_INPUT_HAIR_AA ) 0 ; 
    
#line 245
    uint localVertId = vertexId % ( 6 ) ; 
    uint idx = HairVertexSelection [ localVertId ] ; 
    uint offDirIndex = OffsetDirectionIndex [ localVertId ] ; 
    
#line 250
    float4 hairEdgePositions [ 2 ] ; 
    hairEdgePositions [ 0 ] = float4 ( v [ idx ] + - 1.f * right [ idx ] * ratio [ idx ] * g_FiberRadius , 1.f ) ; 
    hairEdgePositions [ 1 ] = float4 ( v [ idx ] + 1.f * right [ idx ] * ratio [ idx ] * g_FiberRadius , 1.f ) ; 
    hairEdgePositions [ 0 ] = mul ( hairEdgePositions [ 0 ] , g_mViewProj ) ; 
    hairEdgePositions [ 1 ] = mul ( hairEdgePositions [ 1 ] , g_mViewProj ) ; 
    hairEdgePositions [ 0 ] = hairEdgePositions [ 0 ] / hairEdgePositions [ 0 ] . w ; 
    hairEdgePositions [ 1 ] = hairEdgePositions [ 1 ] / hairEdgePositions [ 1 ] . w ; 
    
    Output . Position = hairEdgePositions [ offDirIndex ] + OffsetDirection [ localVertId ] * float4 ( proj_right [ idx ] * expandPixels / g_WinSize . y , 0.0f , 0.0f ) ; 
    Output . Texcoord = float4 ( 0.f , 0.f , ratio [ idx ] , 0.f ) ; 
    Output . Tangent = t [ idx ] ; 
    Output . WorldPos = v [ idx ] ; 
    Output . p0 = hairEdgePositions [ 0 ] . xyz ; 
    Output . p1 = hairEdgePositions [ 1 ] . xyz ; 
    
    return Output ; 
} 

PS_INPUT_HAIR_AA VS_RenderHairNoGS_AlternativeCoverage_StrandCopies ( uint vertexId : SV_VertexID ) 
{ 
    uint RANDOMIZED_GENERATED_VERTEX_COUNT = ( 6 ) * g_iStrandCopies ; 
    
#line 273
    uint offset = 2 * ( vertexId / RANDOMIZED_GENERATED_VERTEX_COUNT ) ; 
    
#line 276
    uint randOffsetIndex = ( vertexId % RANDOMIZED_GENERATED_VERTEX_COUNT ) / ( 6 ) ; 
    
#line 279
    uint seedRand = ( ( offset / 64 + 1 ) * ( randOffsetIndex + 1 ) ) % 512 ; 
    float2 seedTexcorrd = float2 ( float ( seedRand % 512 ) , float ( seedRand / 512 ) ) * ( 1.f / 512.f ) ; 
    float3 randOffset = float3 ( 0 , 0 , 0 ) ; 
    randOffset = float ( randOffsetIndex ) * g_txNoise . SampleLevel ( g_samLinearWrap , seedTexcorrd , 0 ) . xyz ; 
    randOffset = 2.f * randOffset - 1.f ; 
    
#line 286
    uint2 indices ; 
    indices . x = g_HairIndices . Load ( offset ) ; 
    indices . y = g_HairIndices . Load ( offset + 1 ) ; 
    
#line 291
    float ratio [ ] = { 1.f , 1.f } ; 
    
    if ( g_bThinTip > 0 ) 
    { 
        ratio [ 0 ] = g_HairThicknessCoeffs [ indices . x ] ; 
        ratio [ 1 ] = g_HairThicknessCoeffs [ indices . y ] ; 
    } 
    
#line 300
    float3 t [ ] = { normalize ( g_GuideHairVertexTangents [ indices . x ] . xyz ) , normalize ( g_GuideHairVertexTangents [ indices . y ] . xyz ) } ; 
    float3 v [ ] = { randOffset + g_GuideHairVertexPositions [ indices . x ] . xyz , randOffset + g_GuideHairVertexPositions [ indices . y ] . xyz } ; 
    float3 right [ ] = { normalize ( cross ( t [ 0 ] , normalize ( v [ 0 ] - g_vEye ) ) ) , normalize ( cross ( t [ 1 ] , normalize ( v [ 1 ] - g_vEye ) ) ) } ; 
    float2 proj_right [ ] = { normalize ( mul ( float4 ( right [ 0 ] , 0 ) , g_mViewProj ) . xy ) , normalize ( mul ( float4 ( right [ 1 ] , 0 ) , g_mViewProj ) . xy ) } ; 
    
    float expandPixels = .71f ; 
    if ( g_bExpandPixels < 0 ) 
    expandPixels = 0.f ; 
    
    PS_INPUT_HAIR_AA Output = ( PS_INPUT_HAIR_AA ) 0 ; 
    
#line 312
    uint localVertId = vertexId % ( 6 ) ; 
    uint idx = HairVertexSelection [ localVertId ] ; 
    uint offDirIndex = OffsetDirectionIndex [ localVertId ] ; 
    
#line 317
    float4 hairEdgePositions [ 2 ] ; 
    hairEdgePositions [ 0 ] = float4 ( v [ idx ] + - 1.f * right [ idx ] * ratio [ idx ] * g_FiberRadius , 1.f ) ; 
    hairEdgePositions [ 1 ] = float4 ( v [ idx ] + 1.f * right [ idx ] * ratio [ idx ] * g_FiberRadius , 1.f ) ; 
    hairEdgePositions [ 0 ] = mul ( hairEdgePositions [ 0 ] , g_mViewProj ) ; 
    hairEdgePositions [ 1 ] = mul ( hairEdgePositions [ 1 ] , g_mViewProj ) ; 
    hairEdgePositions [ 0 ] = hairEdgePositions [ 0 ] / hairEdgePositions [ 0 ] . w ; 
    hairEdgePositions [ 1 ] = hairEdgePositions [ 1 ] / hairEdgePositions [ 1 ] . w ; 
    
    Output . Position = hairEdgePositions [ offDirIndex ] + OffsetDirection [ localVertId ] * float4 ( proj_right [ idx ] * expandPixels / g_WinSize . y , 0.0f , 0.0f ) ; 
    Output . Texcoord = float4 ( 0.f , 0.f , ratio [ idx ] , 0.f ) ; 
    Output . Tangent = t [ idx ] ; 
    Output . WorldPos = v [ idx ] ; 
    Output . p0 = hairEdgePositions [ 0 ] . xyz ; 
    Output . p1 = hairEdgePositions [ 1 ] . xyz ; 
    
    return Output ; 
} 

float4 HairColor ( float4 iTex , float amountLight ) 
{ 
    float4 baseColor = g_MatBaseColor ; 
    baseColor . xyz = saturate ( baseColor . xyz ) ; 
    baseColor . xyz *= amountLight ; 
    return baseColor ; 
} 

#line 348
float4 KajiyaShading ( float3 iPos , float3 iTangent , float4 iTex , float amountLight ) 
{ 
    float4 baseColor = HairColor ( iTex , 1 ) ; 
    float4 rand_value = float4 ( 1 , 1 , 1 , 1 ) ; 
    
    if ( abs ( iTex . x ) + abs ( iTex . y ) > 1e-5 ) 
    rand_value = g_txNoise . SampleLevel ( g_samLinearWrap , iTex . xy , 0 ) ; 
    
#line 357
    float Ka = g_MatKValue . x , Kd = g_MatKValue . y , 
    Ks1 = g_MatKValue . z , Ex1 = g_MatKValue . w , 
    Ks2 = g_fHairKs2 , Ex2 = g_fHairEx2 ; 
    
    float3 lightPos = g_PointLightPos . xyz ; 
    float3 vLightDir = normalize ( lightPos - iPos . xyz ) ; 
    float3 vEyeDir = normalize ( g_vEye . xyz - iPos . xyz ) ; 
    float3 tangent = normalize ( iTangent ) ; 
    
#line 367
    float cosTL = ( dot ( tangent , vLightDir ) ) ; 
    float sinTL = sqrt ( 1 - cosTL * cosTL ) ; 
    float vDiffuse = sinTL ; 
    
    float alpha = ( rand_value . x * 10 ) * 3.1415926 / 180 ; 
    
#line 374
    float cosTRL = - cosTL ; 
    float sinTRL = sinTL ; 
    float cosTE = ( dot ( tangent , vEyeDir ) ) ; 
    float sinTE = sqrt ( 1 - cosTE * cosTE ) ; 
    
#line 380
    float cosTRL_r = cosTRL * cos ( 2 * alpha ) - sinTRL * sin ( 2 * alpha ) ; 
    float sinTRL_r = sqrt ( 1 - cosTRL_r * cosTRL_r ) ; 
    float vSpecular_r = max ( 0 , cosTRL_r * cosTE + sinTRL_r * sinTE ) ; 
    
#line 385
    float cosTRL_trt = cosTRL * cos ( - 3 * alpha ) - sinTRL * sin ( - 3 * alpha ) ; 
    float sinTRL_trt = sqrt ( 1 - cosTRL_trt * cosTRL_trt ) ; 
    float vSpecular_trt = max ( 0 , cosTRL_trt * cosTE + sinTRL_trt * sinTE ) ; 
    
    float4 vColor = Ka * g_AmbientLightColor * baseColor + 
    amountLight * g_PointLightColor * ( 
    Kd * vDiffuse * baseColor + 
    Ks1 * pow ( vSpecular_r , Ex1 ) + 
    Ks2 * pow ( vSpecular_trt , Ex2 ) * baseColor ) ; 
    
    return vColor ; 
} 

float4 ComputeHairShading ( float3 iPos , float3 iTangent , 
float4 iTex , float amountLight ) 
{ 
    return KajiyaShading ( iPos , iTangent , iTex , amountLight ) ; 
} 

#line 16 "C:\\MINDCODETECH\\GAMEENGINE\\amdcodes\\TressFX11_v1.0\\TressFX11\\shaders\\Source\\kbuffer.hlsl"
void StoreFragments_Hair ( uint x , uint y , float depthNDC , float4 vColor ) 
{ 
    
#line 20
    float2 winSizeEye = float2 ( g_WinSize . xy ) ; 
    
#line 23
    uint uPixelCount = EyeFragmentUAV . IncrementCounter ( ) ; 
    uint uStartOffsetLinearAddress = 4 * ( winSizeEye . x * y + x ) ; 
    uint uOldStartOffset ; 
    
#line 28
    EyeRefUAV . InterlockedExchange ( uStartOffsetLinearAddress , uPixelCount , uOldStartOffset ) ; 
    
#line 31
    Eye_Fragment_STRUCT Element ; 
    Element . uPixelColor = PackFloat4IntoUint ( vColor ) ; 
    Element . uDepthAndCoverage = PackDepthIntoUint ( depthNDC ) ; 
    Element . uNext = uOldStartOffset ; 
    EyeFragmentUAV [ uPixelCount ] = Element ; 
} 

#line 40
[ earlydepthstencil ] 
float4 PS_ABuffer_Hair ( PS_INPUT_HAIR_AA In ) : SV_Target 
{ 
    
#line 45
    INPUT_SHADOW inShadow ; 
    inShadow . pos = In . WorldPos ; 
    AmountLight amountLight = ComputeShadow ( inShadow , g_HairShadowAlpha , g_iTechSM ) ; 
    float light = amountLight . amountLight_scene * amountLight . amountLight_hair ; 
    float4 vColor = ComputeHairShading ( In . WorldPos , In . Tangent , In . Texcoord , light ) ; 
    
    vColor . w = g_FiberAlpha ; 
    
#line 55
    float2 winSizeEye = float2 ( g_WinSize . xy ) ; 
    float4 proj_pos = float4 ( 2 * ( In . Position . x - winSizeEye . x / 2 ) / winSizeEye . x , 
    2 * ( winSizeEye . y / 2 - In . Position . y ) / winSizeEye . y , 1 , 1 ) ; 
    
    float4 original_pos = mul ( proj_pos , g_mInvViewProj ) ; 
    float3 ray_dir = normalize ( original_pos . xyz / original_pos . w - g_vEye ) ; 
    
    float curve_scale = 1 ; 
    if ( g_bThinTip > 0 ) 
    curve_scale = In . Texcoord . z ; 
    
    float fiber_radius = curve_scale * g_FiberRadius ; 
    
    float coverage = 1.f ; 
    if ( g_bUseCoverage ) 
    { 
        if ( g_bUseAltCoverage ) 
        coverage = FastComputeCoverage ( In . p0 . xy , In . p1 . xy , proj_pos . xy ) ; 
        else 
        coverage = ComputeCoverage ( g_vEye , ray_dir , In . p0 , In . p1 , winSizeEye , fiber_radius ) ; 
        
        vColor . w *= coverage ; 
    } 
    
#line 81
    if ( vColor . w > 0.99f / 255.f ) 
    { 
        float4 projPosEye = mul ( float4 ( In . WorldPos , 1 ) , g_mViewProj ) ; 
        float depthNDC = projPosEye . z / projPosEye . w ; 
        StoreFragments_Hair ( In . Position . x , In . Position . y , depthNDC , vColor ) ; 
    } 
    
    return float4 ( 1 , 0 , 0 , 0 ) ; 
} 

[ earlydepthstencil ] 
float4 PS_DrawTopKEye_SelectBlend ( VS_OUTPUT_SCREENQUAD In ) : SV_Target 
{ 
    float4 fcolor = float4 ( 0 , 0 , 0 , 1 ) ; 
    
#line 97
    uint2 nodeList [ 8 ] ; 
    
    [ unroll ] for ( int t = 0 ; t < 8 ; t ++ ) 
    nodeList [ t ] = uint2 ( 0xFFFFFFFF , 0x00000000 ) ; 
    
    float2 winSizeEye = float2 ( g_WinSize . xy ) ; 
    uint x = In . vPosition . x ; 
    uint y = In . vPosition . y ; 
    uint linearAddress = winSizeEye . x * y + x ; 
    
    uint pointer = EyeRefSRV . Load ( linearAddress ) ; 
    
#line 110
    [ unroll ] for ( int p = 0 ; p < 8 ; p ++ ) 
    { 
        [ flatten ] if ( pointer != 0xFFFFFFFF ) 
        { 
            Eye_Fragment_STRUCT node = EyeFragmentSRV [ pointer ] ; 
            nodeList [ p ] = uint2 ( node . uDepthAndCoverage , node . uPixelColor ) ; 
            pointer = node . uNext ; 
        } 
    } 
    
#line 121
    [ allow_uav_condition ] 
    for ( int l = 0 ; l < 768 ; l ++ ) 
    { 
        if ( pointer == 0xFFFFFFFF ) break ; 
        
        Eye_Fragment_STRUCT node = EyeFragmentSRV [ pointer ] ; 
        
        int id = 0 ; 
        uint max_depth = 0 ; 
        
        [ unroll ] for ( int i = 0 ; i < 8 ; i ++ ) 
        { 
            if ( max_depth < nodeList [ i ] . x ) 
            { 
                max_depth = nodeList [ i ] . x ; 
                id = i ; 
            } 
        } 
        
        uint uColor = node . uPixelColor ; 
        
#line 143
        if ( max_depth > node . uDepthAndCoverage ) 
        { 
            uColor = nodeList [ id ] . y ; 
            nodeList [ id ] = uint2 ( node . uDepthAndCoverage , node . uPixelColor ) ; 
        } 
        
#line 150
        float4 color = UnpackUintIntoFloat4 ( uColor ) ; 
        fcolor . xyz = fcolor . xyz * ( 1 - color . w ) + color . xyz * color . w ; 
        fcolor . w *= 1 - color . w ; 
        
        pointer = node . uNext ; 
    } 
    
#line 159
    for ( int j = 0 ; j < 8 ; j ++ ) 
    { 
        int id = 0 ; 
        uint max_depth = 0 ; 
        
        [ unroll ] for ( int i = 0 ; i < 8 ; i ++ ) 
        { 
            if ( max_depth < nodeList [ i ] . x ) 
            { 
                max_depth = nodeList [ i ] . x ; 
                id = i ; 
            } 
        } 
        
        nodeList [ id ] . x = 0x00000000 ; 
        uint uColor = nodeList [ id ] . y ; 
        
        float4 color = UnpackUintIntoFloat4 ( uColor ) ; 
        fcolor . xyz = fcolor . xyz * ( 1 - color . w ) + color . xyz * color . w ; 
        fcolor . w *= 1 - color . w ; 
    } 
    
    return fcolor ; 
} 
 